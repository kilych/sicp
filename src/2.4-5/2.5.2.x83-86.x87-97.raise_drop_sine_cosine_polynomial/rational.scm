(define (install-rational-package)
  ;; Selectors
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  ;; Constructor
  ;; works too:
  ;; (define (make-rat n d)
  ;;   (if (=zero? d)
  ;;       (error "MAKE-RAT: Zero denominator" (list n d))
  ;;       (let ((g (greatest-common-divisor n d)))
  ;;         (cons (div n g) (div d g)))))
  ;; x97:
  (define (make-rat n d)
    (if (=zero? d)
        (error "MAKE-RAT: Zero denominator" (list n d))
        (let ((R (reduce n d))) (cons (car R) (cadr R)))))
  ;; Operations
  (define (add-rat x y)
    (let ((n (numer x))
          (d (denom x))
          (p (numer y))
          (q (denom y)))
      (make-rat (add (mul n q) (mul p d))
                (mul d q))))
  (define (sub-rat x y)
    (let ((n (numer x))
          (d (denom x))
          (p (numer y))
          (q (denom y)))
      (make-rat (sub (mul n q) (mul p d))
                (mul d q))))
  (define (mul-rat x y)
    (let ((n (numer x))
          (d (denom x))
          (p (numer y))
          (q (denom y)))
      (make-rat (mul n p)
                (mul d q))))
  (define (div-rat x y)
    (let ((n (numer x))
          (d (denom x))
          (p (numer y))
          (q (denom y)))
      (make-rat (mul n q)
                (mul d p))))
  (define (change-of-sign-rat x)
    (make-rat (change-of-sign (numer x)) (denom x)))
  ;; Predicates
  (define (equ-rat? x y)
    (let ((n (numer x))
          (d (denom x))
          (p (numer y))
          (q (denom y)))
      (equ? (mul n q) (mul p d))))
  (define (zero-rat? x) (=zero? (numer x)))
  ;; raise
  (define (raise x) (make-scheme-number (div (numer x) (denom x))))
  ;; Adding procs to proc-table
  ;; In SICP tagging is when putting procs to table for all packages.
  (define (tag q) (attach-tag 'rational q))
  (define (with-tag proc) (lambda (. args) (tag (apply proc args))))
  (put 'add '(rational rational) (with-tag add-rat))
  (put 'sub '(rational rational) (with-tag sub-rat))
  (put 'mul '(rational rational) (with-tag mul-rat))
  (put 'div '(rational rational) (with-tag div-rat))
  (put 'equ? '(rational rational) equ-rat?)
  (put '=zero? '(rational) zero-rat?)
  (put 'numer '(rational) numer)
  (put 'denom '(rational) denom)
  (put 'make 'rational (with-tag make-rat))
  ;; unary
  (put 'add '(rational) with-tag)
  (put 'sub '(rational) with-tag)
  (put 'mul '(rational) with-tag)
  (put 'div '(rational) with-tag)
  (put 'change-of-sign '(rational) (with-tag change-of-sign-rat))
  (put 'equ? '(rational) (lambda (p) #t))
  ;; trigonometric
  (put 'arctangent '(rational rational)
       (lambda (y x)
         (let ((p (div-rat y x))) (atan (numer p) (denom p)))))
  ;; raise
  (put 'raise '(rational) raise)
  'done)
